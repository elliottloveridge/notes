# Properties

- A property method is used in conjunction with [[Getters and Setters|getters and setters]] when defining a class with [[Data Attributes#Non-Public Attributes|non-public attributes]]
- The property method lets you define three methods and a variable
	- `fget`: provide a getter function
		- If you don't specify this but specify `fset` then it will be write-only
	- `fset`: provide a setter function
		- If you don't specify this it will be read-only
	- `fdel`: provide a function to delete the attribute
		- Useful if the property is a list, for example
	- `doc`: docstring to provide a description of the property

## Class Properties
- You can create shared properties across class instances using the below
	- You define it outside of initialisation but it still gets referenced within the class as self.property
```python
class Example:
	example_property = 'hello'

	def __init__(self, input_parameter):
		self.input_parameter = input_parameter

	def get_property(self):
		return self.example_property
```
- There are some caveats to the above
	-  A string is immutable and therefore you couldn't update example_property for one class instance and have it update the other
	- A list is mutable and therefore updating for one class instance will also update for another

## Standard Format
- The standard format (not commonly used) allows you to create getters and setters separately from their property definition
```python
# Getter
def _get_lives(self):
	return self._lives

# Setter
def _set_lives(self, lives):
	self._lives = lives

# Property definition
lives = property(_get_lives, _set_lives)
```

- Although not required you could define the property as the following
	- `lives = property(fget=_get_lives, fset=_set_lives)`

## Decorators Format
- [[Decorators]] are more commonly used for defining both properties and getters and setters
	- Takes care of the property definition that you would otherwise have to write
	- People tend to prefer this
- Below is an example decorator used for the score data attribute
```python
class Player(object):

	def __init__(self, name):
		self.name = name
		# Underscore represents hidden variable (outside of Class)
		self._lives = 3
		self._level = 1
		self._score = 0
	
	# Underscore represents hidden getter method
	def _get_lives(self):
		return self._lives
	
	# Underscore represents hidden setter method
	def _set_lives(self, lives):
		if lives >= 0:
			self._lives = lives
		else:
			print("Lives cannot be negative")
			self._lives = 0
	
	# Define getter for level
	def _get_level(self):
		return self._level
	
	# Define setter for level
	def _set_level(self, level):
		if level > 0:
			delta = level - self._level
			self._score += delta * 1000
			self._level = level
		else:
			print("Level cannot be less than 1")

	# Create properties of data attributes
	lives = property(_get_lives, _set_lives)
	level = property(_get_level, _set_level)

	# Using a decorator to define a property and getter (alternate form)
	@property
	def score(self):
		return self._score

	# Using a decorator to define a setter
	@score.setter
	def score(self, score):
		self._score = score
		
	# Special method - string representation of the object
	def __str__(self):
		return "Name: {0.name}, Lives: {0.lives}, Level: {0.level}, Score: {0.score}".format(self)
```

